-- ============================================================================
-- COMPLETE MIGRATION - Fixed Order Without Circular Dependencies
-- ============================================================================
-- This migration creates both webhook_events and updates reservations
-- in the correct order to avoid circular foreign key dependencies

-- ============================================================================
-- STEP 1: Create webhook_events table (without FK to reservations)
-- ============================================================================
CREATE TABLE IF NOT EXISTS webhook_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider TEXT NOT NULL CHECK (provider IN ('stripe', 'paypal')),
  event_id TEXT NOT NULL,
  event_type TEXT NOT NULL,
  processed BOOLEAN NOT NULL DEFAULT FALSE,
  processing_started_at TIMESTAMPTZ,
  processed_at TIMESTAMPTZ,
  processing_error TEXT,
  idempotency_key TEXT,
  reservation_id UUID,  -- Changed from BIGINT to UUID to match reservations.id type
  payload JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes for webhook_events
CREATE INDEX IF NOT EXISTS idx_webhook_events_provider_event_id ON webhook_events(provider, event_id);
CREATE INDEX IF NOT EXISTS idx_webhook_events_idempotency_key ON webhook_events(idempotency_key);
CREATE INDEX IF NOT EXISTS idx_webhook_events_reservation_id ON webhook_events(reservation_id);
CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed);
CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at);

-- Add unique constraints for webhook_events
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'unique_webhook_event'
  ) THEN
    ALTER TABLE webhook_events ADD CONSTRAINT unique_webhook_event
      UNIQUE (provider, event_id);
  END IF;
END
$$;

CREATE UNIQUE INDEX IF NOT EXISTS unique_idempotency_key
  ON webhook_events(idempotency_key)
  WHERE idempotency_key IS NOT NULL;

-- Add RLS for webhook_events
ALTER TABLE webhook_events ENABLE ROW LEVEL SECURITY;

-- Drop policy if exists and recreate
DO $$
BEGIN
  DROP POLICY IF EXISTS "System full access to webhook_events" ON webhook_events;
  CREATE POLICY "System full access to webhook_events" ON webhook_events
    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');
END
$$;

-- Create function to update webhook_events updated_at timestamp
CREATE OR REPLACE FUNCTION update_webhook_events_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for webhook_events
DO $$
BEGIN
  DROP TRIGGER IF EXISTS webhook_events_updated_at ON webhook_events;
  CREATE TRIGGER webhook_events_updated_at
    BEFORE UPDATE ON webhook_events
    FOR EACH ROW
    EXECUTE PROCEDURE update_webhook_events_updated_at();
END
$$;

-- ============================================================================
-- STEP 2: Add missing columns to reservations
-- ============================================================================
DO $$
BEGIN
  -- Add payment_provider column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'payment_provider'
  ) THEN
    ALTER TABLE reservations ADD COLUMN payment_provider TEXT CHECK (payment_provider IN ('stripe', 'paypal'));
  END IF;

  -- Add external_payment_id column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'external_payment_id'
  ) THEN
    ALTER TABLE reservations ADD COLUMN external_payment_id TEXT;
  END IF;

  -- Add webhook_event_id column WITHOUT FK (will add FK in step 4)
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'webhook_event_id'
  ) THEN
    ALTER TABLE reservations ADD COLUMN webhook_event_id BIGINT;
  END IF;

  -- Add expires_at column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'expires_at'
  ) THEN
    ALTER TABLE reservations ADD COLUMN expires_at TIMESTAMPTZ;
  END IF;

  -- Add amount column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'amount'
  ) THEN
    ALTER TABLE reservations ADD COLUMN amount DECIMAL(10,2);
  END IF;

  -- Add updated_at column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'reservations' AND column_name = 'updated_at'
  ) THEN
    ALTER TABLE reservations ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW();
  END IF;
END
$$;

-- ============================================================================
-- STEP 3: Add indexes for reservations
-- ============================================================================
CREATE INDEX IF NOT EXISTS idx_reservations_puppy_id ON reservations(puppy_id);
CREATE INDEX IF NOT EXISTS idx_reservations_status ON reservations(status);
CREATE INDEX IF NOT EXISTS idx_reservations_payment_provider ON reservations(payment_provider);
CREATE INDEX IF NOT EXISTS idx_reservations_external_payment_id ON reservations(external_payment_id);
CREATE INDEX IF NOT EXISTS idx_reservations_webhook_event_id ON reservations(webhook_event_id);
CREATE INDEX IF NOT EXISTS idx_reservations_expires_at ON reservations(expires_at);
CREATE INDEX IF NOT EXISTS idx_reservations_created_at ON reservations(created_at);

-- Add unique constraints using partial indexes
CREATE UNIQUE INDEX IF NOT EXISTS unique_external_payment_per_provider
  ON reservations(payment_provider, external_payment_id)
  WHERE payment_provider IS NOT NULL AND external_payment_id IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_one_active_reservation_per_puppy
  ON reservations(puppy_id)
  WHERE status IN ('pending', 'paid');

-- ============================================================================
-- STEP 4: Add foreign keys (now both tables exist)
-- ============================================================================
DO $$
BEGIN
  -- Add FK from reservations to webhook_events
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'reservations_webhook_event_id_fkey'
  ) THEN
    ALTER TABLE reservations
      ADD CONSTRAINT reservations_webhook_event_id_fkey
      FOREIGN KEY (webhook_event_id)
      REFERENCES webhook_events(id)
      ON DELETE SET NULL;
  END IF;

  -- Add FK from webhook_events to reservations
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'webhook_events_reservation_id_fkey'
  ) THEN
    ALTER TABLE webhook_events
      ADD CONSTRAINT webhook_events_reservation_id_fkey
      FOREIGN KEY (reservation_id)
      REFERENCES reservations(id)
      ON DELETE SET NULL;
  END IF;
END
$$;

-- ============================================================================
-- STEP 5: Add check constraints for reservations
-- ============================================================================
DO $$
BEGIN
  -- Add amount constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'valid_reservation_amount'
  ) THEN
    ALTER TABLE reservations ADD CONSTRAINT valid_reservation_amount
      CHECK (amount IS NULL OR amount >= 0);
  END IF;

  -- Add status constraint if it doesn't exist
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'valid_reservation_status'
  ) THEN
    ALTER TABLE reservations ADD CONSTRAINT valid_reservation_status
      CHECK (status IN ('pending', 'paid', 'cancelled', 'expired', 'refunded'));
  END IF;
END
$$;

-- ============================================================================
-- STEP 6: Create helper functions for reservations
-- ============================================================================

-- Function to check puppy availability
CREATE OR REPLACE FUNCTION check_puppy_availability()
RETURNS TRIGGER AS $$
DECLARE
  puppy_available BOOLEAN;
BEGIN
  -- Check if puppy is still available for new reservations
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.status IN ('pending', 'paid')) THEN
    SELECT (
      SELECT COUNT(*) = 0
      FROM reservations
      WHERE puppy_id = NEW.puppy_id
      AND status IN ('pending', 'paid')
      AND id != COALESCE(NEW.id, 0)
    ) INTO puppy_available;

    IF NOT puppy_available THEN
      RAISE EXCEPTION 'Puppy is not available for reservation';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to automatically expire pending reservations
CREATE OR REPLACE FUNCTION expire_pending_reservations()
RETURNS VOID AS $$
BEGIN
  UPDATE reservations
  SET status = 'expired', updated_at = NOW()
  WHERE status = 'pending'
  AND expires_at IS NOT NULL
  AND expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- Function to get reservation summary
CREATE OR REPLACE FUNCTION get_reservation_summary(puppy_id_param UUID)
RETURNS TABLE(
  total_reservations BIGINT,
  pending_reservations BIGINT,
  paid_reservations BIGINT,
  total_amount DECIMAL(10,2)
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::BIGINT,
    COUNT(*) FILTER (WHERE status = 'pending')::BIGINT,
    COUNT(*) FILTER (WHERE status = 'paid')::BIGINT,
    COALESCE(SUM(amount), 0)::DECIMAL(10,2)
  FROM reservations
  WHERE puppy_id = puppy_id_param;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- STEP 7: Add trigger for reservations
-- ============================================================================
DO $$
BEGIN
  DROP TRIGGER IF EXISTS enforce_puppy_availability ON reservations;
  CREATE TRIGGER enforce_puppy_availability
    BEFORE INSERT OR UPDATE ON reservations
    FOR EACH ROW
    EXECUTE FUNCTION check_puppy_availability();
END
$$;

-- ============================================================================
-- STEP 8: Create main transaction function
-- ============================================================================
CREATE OR REPLACE FUNCTION create_reservation_transaction(
  p_puppy_id UUID,
  p_customer_name TEXT,
  p_customer_email TEXT,
  p_customer_phone TEXT,
  p_channel TEXT,
  p_deposit_amount NUMERIC,
  p_amount NUMERIC,
  p_payment_provider TEXT,
  p_external_payment_id TEXT,
  p_expires_at TIMESTAMPTZ,
  p_notes TEXT
)
RETURNS reservations
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_puppy puppies%ROWTYPE;
  v_reservation reservations%ROWTYPE;
BEGIN
  SELECT *
  INTO v_puppy
  FROM puppies
  WHERE id = p_puppy_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'PUPPY_NOT_FOUND';
  END IF;

  IF v_puppy.status IS DISTINCT FROM 'available' THEN
    RAISE EXCEPTION 'PUPPY_NOT_AVAILABLE';
  END IF;

  IF v_puppy.price_usd IS NOT NULL AND p_deposit_amount > v_puppy.price_usd THEN
    RAISE EXCEPTION 'DEPOSIT_EXCEEDS_PRICE';
  END IF;

  UPDATE puppies
  SET status = 'reserved',
      updated_at = NOW()
  WHERE id = p_puppy_id;

  INSERT INTO reservations (
    puppy_id,
    customer_name,
    customer_email,
    customer_phone,
    channel,
    status,
    deposit_amount,
    amount,
    payment_provider,
    external_payment_id,
    expires_at,
    notes,
    created_at,
    updated_at
  )
  VALUES (
    p_puppy_id,
    NULLIF(TRIM(p_customer_name), ''),
    LOWER(TRIM(p_customer_email)),
    NULLIF(TRIM(p_customer_phone), ''),
    COALESCE(p_channel, 'site'),
    'pending',
    p_deposit_amount,
    p_amount,
    p_payment_provider,
    p_external_payment_id,
    p_expires_at,
    NULLIF(TRIM(p_notes), ''),
    NOW(),
    NOW()
  )
  RETURNING *
  INTO v_reservation;

  RETURN v_reservation;
END;
$$;

-- ============================================================================
-- STEP 9: Grant permissions
-- ============================================================================
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT SELECT ON reservations TO anon, authenticated;
GRANT SELECT ON webhook_events TO authenticated;
GRANT ALL ON reservations TO service_role;
GRANT ALL ON webhook_events TO service_role;

GRANT EXECUTE ON FUNCTION create_reservation_transaction(
  UUID, TEXT, TEXT, TEXT, TEXT, NUMERIC, NUMERIC, TEXT, TEXT, TIMESTAMPTZ, TEXT
) TO service_role;

-- ============================================================================
-- STEP 10: Add comments for documentation
-- ============================================================================
COMMENT ON TABLE webhook_events IS 'Tracks all incoming payment webhook events for audit trail and idempotency management';
COMMENT ON COLUMN webhook_events.provider IS 'Payment provider: stripe or paypal';
COMMENT ON COLUMN webhook_events.event_id IS 'Unique event identifier from the provider';
COMMENT ON COLUMN webhook_events.event_type IS 'Type of event (e.g., payment_intent.succeeded, checkout.session.completed)';
COMMENT ON COLUMN webhook_events.processed IS 'Whether the webhook has been successfully processed';
COMMENT ON COLUMN webhook_events.idempotency_key IS 'Key to prevent duplicate processing';
COMMENT ON COLUMN webhook_events.reservation_id IS 'Related reservation if applicable';

COMMENT ON COLUMN reservations.payment_provider IS 'Payment provider: stripe or paypal';
COMMENT ON COLUMN reservations.external_payment_id IS 'External payment ID from provider (e.g., Stripe Payment Intent ID)';
COMMENT ON COLUMN reservations.webhook_event_id IS 'Reference to the webhook event that created this reservation';
COMMENT ON COLUMN reservations.expires_at IS 'When the reservation expires if not paid';

-- ============================================================================
-- Migration Complete!
-- ============================================================================
